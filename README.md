# 「飛機頭頂預警」MVP 計畫書（免費版）

**TL;DR：** 這個 MVP 針對固定地點（如演出場地）預測「飛機壓頂」事件，先在 OpenSky 免費匿名 API 限制下實作倒數提醒、通過時長與噪音等級。核心功能是持續取得航機狀態、計算最近接近時間與半徑進出點，並在 Web 介面上提供演出模式提示，協助現場人員提前降噪或調整橋段。

## 1. 企劃概述（為何要做）

* **使用情境**：臺北市中山區圓山里（靠近松山機場航道），11 月晚間會有露天音樂會；希望在演出與收音時段**提前 10–30 秒**知道是否有飛機將「壓到頭頂」，並顯示**預估通過時長（尚未進入）或剩餘通過秒數（已在半徑內）**與**噪音等級（粗估）**，方便臨時降噪、靜音或橋段調度。
* **MVP 目標**（免費、非商用初版）：

  1. 即時輪詢附近飛機位置，
  2. 計算飛機與指定地點的**最近接近時間（ETA）**與**停留時長**，
  3. UI 顯示**倒數**與**預估／剩餘通過秒數**（依情境切換），並列表未來幾架可能壓頂的航機。
* **成功指標**：

  * 提前預警**命中率 ≥ 85%**（以現地記錄核對）
  * **誤報率 ≤ 15%**（出現倒數但實際沒有顯著飛越）
  * **端對端延遲 ≤ 5 秒**（API→畫面）

---

## 2. 需求與範圍（MVP）

### 必要功能（Must）

* 固定地點（可手動輸入/定位）之**飛機通過倒數**與**預估／剩餘通過秒數**顯示
* 清單：未來 3–5 架可能進入半徑區域的航機（ETA / 預估／剩餘通過秒數 / 呼號）
* 小地圖：顯示位置圈（半徑 R）與航跡預測線
* 「演出模式」：在 **T–30s**、**T–10s** 自動觸發可見/可聽/震動提示（瀏覽器通知或音效）

### 選配（Should）

* 簡易**噪音等級**估計（高/中/低）
* 信心分數（資料延遲、航向穩定度、連續命中次數）

### 暫不納入（Won’t, 供未來規劃）

* 商用等級 SLA、離線快取、完整軌跡回放、與舞台控台 OSC/MQTT/DMX 整合（可列為 v2）

---

## 3. 資料來源（免費）

* **OpenSky Network REST API**（匿名免費，有速率/範圍限制，研究/非商用友善）

  * 取**狀態向量**（位置、速度、航向、高度、呼號等）
  * **地理方框（bbox）**限制查詢範圍（例如：以圓山里為中心，半徑 \~10–15 km 等效 bbox）

> MVP 以 OpenSky 為主，足以做**短期外推**判定「會不會壓頂」。

* （可選）**METAR 天氣**：用於推定跑道使用方向（風向支配），改善假警報。免費來源多，可在 v1.1 加。

**法遵與使用條款**：OpenSky 免費屬研究/非商用範疇，MVP 僅供內部測試與評估。若要導入正式演出工作流程，後續建議升級至商用資料供應商。

---

## 4. 系統架構（簡潔、便於維運）

* **前端**：Vite + React（或 Svelte）+ Leaflet（地圖）

  * 以 **Web Worker** 處理幾何計算（CPA/進出半徑求解），避免卡 UI
  * PWA 可選（現場 4G/5G 不穩時仍能跑緩存與告警邏輯）
* **後端**：**無伺服器優先**

  * **方案 A：純前端直連 OpenSky**（最快速、零維運；若 CORS/頻率卡關則加薄 proxy）
  * **方案 B：極薄 Proxy**（Cloudflare Workers / Vercel Edge）

    * 集中節流、遮蔽 API、統一誤差處理與格式清洗

**資料流程**

1. 前端固定地點座標（或 GPS）→ 算出查詢 bbox
2. 預設每 **10–12 秒**（符合 OpenSky 匿名速率限制）輪詢一次狀態向量；若改用認證帳號或後端代理，目標是提升至 **3–5 秒** 更新頻率，以支援更可靠的 T–10 秒提醒。
3. 對每架機體做 CPA & 進出半徑 R 的時間解，產生：ETA、通過事件時長（尚未進入半徑時作為預估通過時長，已在半徑內時作為剩餘通過秒數）、最近距離
4. 套用高度門檻與噪音等級規則 → 過濾與排序
5. 畫面更新倒數、大字提醒、地圖軌跡與清單

---

## 5. 核心演算法（可直接實作）

**定義**

* 地點 $P$：(lat, lon)；轉 ENU/UTM 等**局部平面座標**（MVP 規劃使用 `proj4js` 建立 WGS84→本地東北天座標的轉換函式，或以 Cesium/`@math.gl/geospatial` 提供的 ENU 工具）
* 半徑 $R$：建議 **700 m**（後續現勘微調 500–1000 m）
* 飛機狀態：位置 $A_0$、地速 $v$（m/s）、**真航向** $θ$（弧度）、高度 $h$
* 初始相對位置向量：$\vec{r}_0 = A_0 - P$
* 航向單位向量：$\hat{d}(θ) = (\sin θ,\, \cos θ)$

**短時外推**（近似直線、低延遲場景足夠）

$$
A(t) = A_0 + v \cdot t \cdot \hat{d}(θ)
$$

**最近接近時間（CPA）**

$$
t_{\text{CPA}} = -\frac{\vec{r}_0 \cdot \hat{d}(θ)}{v}
$$

**最近距離**

$$
d_{\min} = \left\| \vec{r}_0 + v \cdot t_{\text{CPA}} \cdot \hat{d}(θ) \right\|
$$

若 $d_{\min} \le R$ 且 $h \le h_{\max}$（建議 **3000 m**），視為可能「壓頂」。若飛機已通過最近點但仍在半徑內，仍需繼續追蹤直到離開。

**進出半徑時間（剩餘通過秒數）**
解 $\left\| \vec{r}_0 + v t \hat{d}(θ) \right\| = R$，得兩根 $t_1 < t_{\text{CPA}} < t_2$

* **ETA** = $\max(t_1, 0)$
* **通過事件時長（duration）** = $\max(0, t_2 - \max(t_1,0))$
  * 說明：此公式在航機尚未進入半徑時（$t_1 \ge 0$）會計算**總通過時長**（$t_2 - t_1$）；航機已在半徑內時（$t_1 < 0$）則計算**剩餘停留時間**（$t_2$）。UI 應根據 `eta` 是否為 0 來決定顯示「預估通過時長」或「剩餘通過時間」。

若整個通過事件（$t_1, t_2$）皆位於過去（$t_2 < 0$），才可忽略；否則即使 $t_{\text{CPA}} < 0$ 亦需計算剩餘停留時間。

**噪音等級（啟發式）**

* 估地面觀測距離 $d_g = \sqrt{d_{\min}^2 + h^2}$
* **高**：$d_g < 1200$ m、**中**：$1200 \le d_g < 2500$ m、**低**：$d_g \ge 2500$ m

**抗抖動與誤報處理**

* 必須連續 **2 次輪詢**均命中才發出倒數
* 航向變化超過閾值（例：> 20°/10s）則**降信心**或延後提醒
* 對高度缺失（baro/geo-alt null）時以保守策略處理（不給「高噪音」）

---

## 6. 前端 UI/UX（舞台友善）

* 置頂大字：**下一架 T–01:32**（mm\:ss 倒數）
* 次行：**預估通過 \~ 42 秒｜噪音：中｜信心：0.83**
* 通過中狀態（eta === 0）：主標題切換為 **注意：飛機正在通過！**，次行更新為剩餘秒數倒數（例：**剩餘 18 秒｜噪音：高｜信心：0.83**），並啟用高對比背景提示現場人員抬頭注意
* 地圖：地點圓圈（R）、航機即時點、預測線、CPA 點
* 清單（未來 3–5 架）：ETA / 預估／剩餘通過秒數 / 呼號 / 估噪音
* **演出模式**：

  * T–30s：靜音/降噪提醒（可選音效、震動、瀏覽器通知）
  * T–10s：強提醒（畫面閃爍、字級放大）
* 夜間高對比主題（暗場可見）

---

## 7. 驗證方法與 KPI

**測試步驟**

1. 現地側錄：用手機螢幕錄影 + 環境拾音（標記飛機實際通過時刻）
2. 系統 Log：保存每次提醒之事件（時間戳、航機 id、ETA/實際差）
3. 對時：以 NTP 時計避免手機與 API 時差

**KPI**

* **命中率**：有飛機頭頂（或邊界 R 內）且系統有提前 ≥10s 提醒
* **誤報率**：系統提醒但實地觀感無明顯飛越/噪音
* **時間誤差**：|ETA – 實際通過起點|（目標中位數 ≤ 5–8s）
* **延遲**：API → 畫面更新（≤ 5s）

---

## 8. 里程碑與時程（以人月 0.5–1 為準）

**W1（設計 & 骨架）**

* 決定半徑 R 與 bbox、地圖樣板、Web Worker 計算模組
* 打通 OpenSky 輪詢與資料標準化；基本 CPA 命中判斷
* 先做開發者地圖頁（顯示點、線、圈）

**W2（產品化 & 告警）**

* 大字倒數、清單、夜間主題、演出模式提醒（T–30/T–10）
* 抗抖動策略、信心分數、錯誤處理（無資料、API 失敗）

**W3（驗證 & 報告）**

* 現地測試 3 場次（不同氣候/時間帶）
* 指標統計（命中/誤報/時間誤差/延遲），出測試報告
* 依結果微調 R、門檻、緩衝策略

> 若你要更快 demo：**3–5 天可出 MVP**（但正式驗證數據要靠 W3）

---

## 9. 風險與對策

* **T–10 秒提醒可靠性（匿名輪詢 10–12 s + 網路延遲）**：

  * 對策：將提醒分級（例如維持 T–30 秒為基準），並在匿名模式下明示 T–10 秒僅為最佳努力；若需穩定的 T–10 秒或更緊湊的提醒，應升級至認證帳號或代理以將輪詢頻率拉高至 3–5 秒，並評估緩存/預抓策略。
* **資料延遲 / 覆蓋不均**：

  * 對策：用信心分數揭露、連續命中才推播；若 API 失敗則降頻重試
* **航向突變（轉彎/等待航線）**：

  * 對策：航向不穩定時降低權重；必要時拉長提醒緩衝
* **天氣改變跑道方向**：

  * 對策：加 METAR 風向作加權（v1.1）
* **法律與責任**：

  * 對策：標明「參考用，不構成航安/施工決策依據」；非商用測試

---

## 10. 成本概算（MVP）

* **雲端**：Cloudflare Pages（\$0）、Workers（開發期幾乎 \$0）
* **API**：OpenSky（\$0、非商用限制）
* **人工**：0.5–1 人月（前端 + 幾何演算法 + 驗證）

---

## 11. 未來擴充（v1.1～v2）

* v1.1：接 **METAR** 推測跑道、改善假警報；加入「歷史回放」便於教練與檢討
* v1.5：若要準備正式演出，評估接**商用 ADS-B 供應商**（更高更新頻率/查詢半徑/穩定性）、加上**快取/排程**
* v2：**舞台系統整合**（Webhook/OSC/MQTT）、多地點感知（主舞台/副舞台）、**SLA 與監控**、匿名化資料留存（只存事件摘要）

---

## 12. 系統規格摘要（便於審查）

* **技術棧**：Vite + React、Leaflet、TypeScript、Web Worker、（可選）Cloudflare Workers
* **核心演算法**：CPA + 進出半徑解析（封裝為 `computePassEvent()`）
* **查詢頻率**：預設 10-12 s（符合 OpenSky 匿名速率限制）；若需可靠達成 T–10 秒提醒，須搭配認證帳號或後端代理將頻率提升至 3-5 s。
* **預設參數**：R=700m、`h_max`=3000m、連續命中次數=2、T–30/T–10 提醒
* **可設定**：地點座標、半徑 R、提醒門檻、輪詢頻率、夜間模式

---

## 13. 交付物（本案評審關心）

1. **可跑的 MVP 前端**（URL / QR code）
2. **設定檔**（地點、R、頻率）與**部署說明**
3. **簡短測試報告**（命中率、誤報率、時間誤差、中山區 1–2 次實測截圖）
4. **Roadmap**（v1.1–v2 升級與商用評估清單）

---

### 附錄 A：API 欄位對映（OpenSky 常見）

* `latitude`, `longitude` → 位置
* `velocity`（m/s）→ 地速
* `true_track`（度）→ 真航向（使用前請換算為弧度：`trackRad = true_track * Math.PI / 180`）
* `baro_altitude`/`geo_altitude`（m）→ 高度
* `callsign`, `icao24` → 追蹤標識

### 附錄 B：CPA 函式（TS 偽碼，貼進 Web Worker 可用）

```ts
type Plane = { x: number; y: number; v: number; trackRad: number; h?: number; id: string }; // trackRad in radians
type PassEvent = { eta: number; duration: number; dmin: number; level: '高'|'中'|'低' | null; ok: boolean };

export function computePassEvent(P: {x:number;y:number}, p: Plane, R=700, Hmax=3000): PassEvent {
  const ux = Math.sin(p.trackRad), uy = Math.cos(p.trackRad);
  const rx = (p.x - P.x), ry = (p.y - P.y);
  const safe_v = Math.max(p.v, 1e-3);
  const tCPA = -(rx*ux + ry*uy) / safe_v;

  const dx = rx + safe_v*tCPA*ux, dy = ry + safe_v*tCPA*uy;
  const dmin = Math.hypot(dx, dy);
  const h = p.h; // 保留 undefined 的可能性，以便後續判斷
  if (dmin > R || (h != null && h > Hmax)) return {eta: Infinity, duration: 0, dmin, level:null, ok:false};

  // solve ||r0 + v t u|| = R
  const time_to_border = Math.sqrt(Math.max(0, R*R - dmin*dmin)) / safe_v;
  const t1 = tCPA - time_to_border;
  const t2 = tCPA + time_to_border;

  if (t2 < 0) {
    return {eta: Infinity, duration: 0, dmin, level:null, ok:false};
  }

  const eta = Math.max(t1, 0);
  const duration = Math.max(0, t2 - Math.max(t1,0));

  const dg = h == null ? null : Math.hypot(dmin, h);
  const level = dg == null ? null : (dg < 1200 ? '高' : (dg < 2500 ? '中' : '低'));
  return {eta, duration, dmin, level, ok:true};
}
```
